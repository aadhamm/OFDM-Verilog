// -------------------------------------------------------------
// 
// File Name: D:\OFDM\HDLImplementationOfDUCForLTEExample(Single Tone Output)\HDLImplementationOfDUCForLTEExample\hdlsrc\complex_upsampler\DUCforLTEHDL\FIRFilter2_block.v
// Created: 2023-05-25 17:45:33
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: FIRFilter2_block
// Source Path: DUCforLTEHDL/HDL_DUC/Halfband Interpolator/DUCforLTEHDL/HDL_DUC/Halfband Interpolator/FIRFilter2
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module FIRFilter2_block
          (clk,
           reset,
           enb,
           dataIn_re,
           dataIn_im,
           validIn,
           dataOut_re,
           dataOut_im,
           validOut);


  input   clk;
  input   reset;
  input   enb;
  input   signed [17:0] dataIn_re;  // sfix18_En14
  input   signed [17:0] dataIn_im;  // sfix18_En14
  input   validIn;
  output  signed [17:0] dataOut_re;  // sfix18_En14
  output  signed [17:0] dataOut_im;  // sfix18_En14
  output  validOut;


  wire signed [17:0] dinSM_re;  // sfix18_En14
  wire signed [17:0] dinSM_im;  // sfix18_En14
  wire dinVldSM;
  reg [2:0] nextDelayLineRdAddrReverse;  // ufix3
  reg [2:0] rdCountReverse_1;  // ufix3
  reg [2:0] nextDelayLineWrAddr;  // ufix3
  reg [2:0] wrCount_1;  // ufix3
  reg [2:0] nextDelayLineRdAddr;  // ufix3
  reg [2:0] rdCount_1;  // ufix3
  reg [2:0] nextSharingCount;  // ufix3
  reg [2:0] sharingCount_1;  // ufix3
  reg  delayLineValidInP;
  reg  lastPhaseStrobe;
  reg  delayLineShiftEnP;
  reg  [0:4] validOutLookahead_reg;  // ufix1 [5]
  wire [0:4] validOutLookahead_reg_next;  // ufix1 [5]
  wire validOutLookahead_1;
  reg  vldOut_1;
  wire notValid;
  reg [2:0] rdAddr0_1;  // ufix3
  reg signed [17:0] coeffTableOut0;  // sfix18_En16
  reg [2:0] wrAddrP;  // ufix3
  reg [2:0] rdAddrDelayLine0;  // ufix3
  reg signed [17:0] coeffTableRegP0_1;  // sfix18_En16
  wire coeffNonZero;
  wire signed [17:0] delayLineDataOut0;  // sfix18_En14
  wire signed [35:0] gainOut;  // sfix36_En30
  reg signed [35:0] gainOutSwitch;  // sfix36_En30
  reg signed [35:0] filterDelay_reg [0:2];  // sfix36 [3]
  wire signed [35:0] filterDelay_reg_next [0:2];  // sfix36_En30 [3]
  wire signed [35:0] gainOutREG;  // sfix36_En30
  wire signed [33:0] sumOut;  // sfix34_En30
  wire signed [17:0] converterOut;  // sfix18_En14
  reg signed [17:0] dout_re_1;  // sfix18_En14
  reg signed [17:0] coeffTableOut0_1;  // sfix18_En16
  reg signed [17:0] coeffTableRegP0_3;  // sfix18_En16
  wire coeffNonZero_1;
  wire signed [17:0] delayLineDataOut0_1;  // sfix18_En14
  wire signed [35:0] gainOut_1;  // sfix36_En30
  reg signed [35:0] gainOutSwitch_1;  // sfix36_En30
  reg  [0:4] validOutLookahead_reg_1;  // ufix1 [5]
  wire [0:4] validOutLookahead_reg_next_1;  // ufix1 [5]
  wire validOutLookahead_3;
  reg signed [35:0] filterDelay_reg_1 [0:2];  // sfix36 [3]
  wire signed [35:0] filterDelay_reg_next_1 [0:2];  // sfix36_En30 [3]
  wire signed [35:0] gainOutREG_1;  // sfix36_En30
  wire signed [33:0] sumOut_1;  // sfix34_En30
  wire signed [17:0] converterOut_1;  // sfix18_En14
  reg signed [17:0] dout_im_1;  // sfix18_En14
  wire signed [17:0] dataZero;  // sfix18_En14
  wire signed [17:0] dataZero_dtc_re;  // sfix18_En14
  wire signed [17:0] dataZero_dtc_im;  // sfix18_En14
  wire signed [17:0] dout_cmplxSW_re;  // sfix18_En14
  wire signed [17:0] dout_cmplxSW_im;  // sfix18_En14
  reg [2:0] InputControl_out4_0;  // ufix3

  initial begin
    coeffTableRegP0_1 = 18'sb000000000000000000;
    coeffTableRegP0_3 = 18'sb000000000000000000;
  end

  FirRdyLogic_block2 u_firRdyLogic (.clk(clk),
                                    .reset(reset),
                                    .enb(enb),
                                    .dataIn_re(dataIn_re),  // sfix18_En14
                                    .dataIn_im(dataIn_im),  // sfix18_En14
                                    .validIn(validIn),
                                    .dinSM_re(dinSM_re),  // sfix18_En14
                                    .dinSM_im(dinSM_im),  // sfix18_En14
                                    .dinVldSM(dinVldSM)
                                    );

  always @(posedge clk or posedge reset)
    begin : rdCountReverse_process
      if (reset == 1'b1) begin
        rdCountReverse_1 <= 3'b000;
      end
      else begin
        if (enb) begin
          rdCountReverse_1 <= nextDelayLineRdAddrReverse;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : wrCount_process
      if (reset == 1'b1) begin
        wrCount_1 <= 3'b000;
      end
      else begin
        if (enb) begin
          wrCount_1 <= nextDelayLineWrAddr;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : rdCount_process
      if (reset == 1'b1) begin
        rdCount_1 <= 3'b000;
      end
      else begin
        if (enb) begin
          rdCount_1 <= nextDelayLineRdAddr;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : sharingCount_process
      if (reset == 1'b1) begin
        sharingCount_1 <= 3'b000;
      end
      else begin
        if (enb) begin
          sharingCount_1 <= nextSharingCount;
        end
      end
    end



  // Input control counter combinatorial logic
  always @(dinVldSM, rdCountReverse_1, rdCount_1, sharingCount_1, wrCount_1) begin
    delayLineValidInP = (sharingCount_1 == 3'b000) && (dinVldSM == 1'b1);
    lastPhaseStrobe = sharingCount_1 == 3'b111;
    if ((dinVldSM == 1'b1) || (sharingCount_1 > 3'b000)) begin
      if (sharingCount_1 == 3'b111) begin
        nextSharingCount = 3'b000;
      end
      else begin
        nextSharingCount = sharingCount_1 + 3'b001;
      end
    end
    else begin
      nextSharingCount = sharingCount_1;
    end
    if (dinVldSM == 1'b1) begin
      if (wrCount_1 == 3'b111) begin
        InputControl_out4_0 = 3'b000;
      end
      else begin
        InputControl_out4_0 = wrCount_1 + 3'b001;
      end
    end
    else begin
      InputControl_out4_0 = wrCount_1;
    end
    if ((rdCount_1 != InputControl_out4_0) || (dinVldSM == 1'b1)) begin
      if (rdCount_1 == 3'b000) begin
        nextDelayLineRdAddr = 3'b111;
      end
      else begin
        nextDelayLineRdAddr = rdCount_1 - 3'b001;
      end
    end
    else begin
      nextDelayLineRdAddr = rdCount_1;
    end
    if ((sharingCount_1 > 3'b000) || (dinVldSM == 1'b1)) begin
      if (sharingCount_1 == 3'b111) begin
        if (wrCount_1 == 3'b111) begin
          nextDelayLineRdAddrReverse = 3'b000;
        end
        else begin
          nextDelayLineRdAddrReverse = wrCount_1 + 3'b001;
        end
      end
      else if (rdCountReverse_1 == 3'b111) begin
        nextDelayLineRdAddrReverse = 3'b000;
      end
      else begin
        nextDelayLineRdAddrReverse = rdCountReverse_1 + 3'b001;
      end
    end
    else begin
      nextDelayLineRdAddrReverse = rdCountReverse_1;
    end
    nextDelayLineWrAddr = InputControl_out4_0;
  end



  always @(posedge clk or posedge reset)
    begin : delayLineShiftEn0_process
      if (reset == 1'b1) begin
        delayLineShiftEnP <= 1'b0;
      end
      else begin
        if (enb) begin
          delayLineShiftEnP <= lastPhaseStrobe;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : validOutLookahead_process
      if (reset == 1'b1) begin
        validOutLookahead_reg[0] <= 1'b0;
        validOutLookahead_reg[1] <= 1'b0;
        validOutLookahead_reg[2] <= 1'b0;
        validOutLookahead_reg[3] <= 1'b0;
        validOutLookahead_reg[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          validOutLookahead_reg[0] <= validOutLookahead_reg_next[0];
          validOutLookahead_reg[1] <= validOutLookahead_reg_next[1];
          validOutLookahead_reg[2] <= validOutLookahead_reg_next[2];
          validOutLookahead_reg[3] <= validOutLookahead_reg_next[3];
          validOutLookahead_reg[4] <= validOutLookahead_reg_next[4];
        end
      end
    end

  assign validOutLookahead_1 = validOutLookahead_reg[4];
  assign validOutLookahead_reg_next[0] = delayLineShiftEnP;
  assign validOutLookahead_reg_next[1] = validOutLookahead_reg[0];
  assign validOutLookahead_reg_next[2] = validOutLookahead_reg[1];
  assign validOutLookahead_reg_next[3] = validOutLookahead_reg[2];
  assign validOutLookahead_reg_next[4] = validOutLookahead_reg[3];



  always @(posedge clk or posedge reset)
    begin : vldOut_process
      if (reset == 1'b1) begin
        vldOut_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          vldOut_1 <= validOutLookahead_1;
        end
      end
    end



  assign notValid =  ~ vldOut_1;



  always @(posedge clk or posedge reset)
    begin : rdAddr0_process
      if (reset == 1'b1) begin
        rdAddr0_1 <= 3'b000;
      end
      else begin
        if (enb) begin
          rdAddr0_1 <= sharingCount_1;
        end
      end
    end



  // Coefficient table for multiplier0
  always @(rdAddr0_1) begin
    case ( rdAddr0_1)
      3'b000 :
        begin
          coeffTableOut0 = 18'sb000000000000000000;
        end
      3'b001 :
        begin
          coeffTableOut0 = 18'sb000000000000000000;
        end
      3'b010 :
        begin
          coeffTableOut0 = 18'sb000000000000000000;
        end
      3'b011 :
        begin
          coeffTableOut0 = 18'sb010000000000000000;
        end
      3'b100 :
        begin
          coeffTableOut0 = 18'sb000000000000000000;
        end
      3'b101 :
        begin
          coeffTableOut0 = 18'sb000000000000000000;
        end
      3'b110 :
        begin
          coeffTableOut0 = 18'sb000000000000000000;
        end
      3'b111 :
        begin
          coeffTableOut0 = 18'sb000000000000000000;
        end
      default :
        begin
          coeffTableOut0 = 18'sb000000000000000000;
        end
    endcase
  end



  always @(posedge clk or posedge reset)
    begin : wrAddr_process
      if (reset == 1'b1) begin
        wrAddrP <= 3'b000;
      end
      else begin
        if (enb) begin
          wrAddrP <= wrCount_1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : rdAddrDelayLine_process
      if (reset == 1'b1) begin
        rdAddrDelayLine0 <= 3'b000;
      end
      else begin
        if (enb) begin
          rdAddrDelayLine0 <= rdCount_1;
        end
      end
    end



  always @(posedge clk)
    begin : coeffTableRegP0_process
      if (enb) begin
        coeffTableRegP0_1 <= coeffTableOut0;
      end
    end



  assign coeffNonZero = coeffTableRegP0_1 != 18'sb000000000000000000;



  Addressable_Delay_Line_block7 u_delayLine0 (.clk(clk),
                                              .enb(enb),
                                              .dataIn(dinSM_re),  // sfix18_En14
                                              .wrEn(delayLineValidInP),
                                              .wrAddr(wrAddrP),  // ufix3
                                              .rdAddr(rdAddrDelayLine0),  // ufix3
                                              .dataOut(delayLineDataOut0)  // sfix18_En14
                                              );

  assign gainOut = {{2{delayLineDataOut0[17]}}, {delayLineDataOut0, 16'b0000000000000000}};



  always @(posedge clk or posedge reset)
    begin : filterDelay_process
      if (reset == 1'b1) begin
        gainOutSwitch <= 36'sh000000000;
      end
      else begin
        if (enb && coeffNonZero) begin
          gainOutSwitch <= gainOut;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : filterDelay_1_process
      if (reset == 1'b1) begin
        filterDelay_reg[0] <= 36'sh000000000;
        filterDelay_reg[1] <= 36'sh000000000;
        filterDelay_reg[2] <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          filterDelay_reg[0] <= filterDelay_reg_next[0];
          filterDelay_reg[1] <= filterDelay_reg_next[1];
          filterDelay_reg[2] <= filterDelay_reg_next[2];
        end
      end
    end

  assign gainOutREG = filterDelay_reg[2];
  assign filterDelay_reg_next[0] = gainOutSwitch;
  assign filterDelay_reg_next[1] = filterDelay_reg[0];
  assign filterDelay_reg_next[2] = filterDelay_reg[1];



  assign sumOut = gainOutREG[33:0];



  assign converterOut = sumOut[33:16];



  always @(posedge clk or posedge reset)
    begin : dout_re_process
      if (reset == 1'b1) begin
        dout_re_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb && validOutLookahead_1) begin
          dout_re_1 <= converterOut;
        end
      end
    end



  // Coefficient table for multiplier0
  always @(rdAddr0_1) begin
    case ( rdAddr0_1)
      3'b000 :
        begin
          coeffTableOut0_1 = 18'sb000000000000000000;
        end
      3'b001 :
        begin
          coeffTableOut0_1 = 18'sb000000000000000000;
        end
      3'b010 :
        begin
          coeffTableOut0_1 = 18'sb000000000000000000;
        end
      3'b011 :
        begin
          coeffTableOut0_1 = 18'sb010000000000000000;
        end
      3'b100 :
        begin
          coeffTableOut0_1 = 18'sb000000000000000000;
        end
      3'b101 :
        begin
          coeffTableOut0_1 = 18'sb000000000000000000;
        end
      3'b110 :
        begin
          coeffTableOut0_1 = 18'sb000000000000000000;
        end
      3'b111 :
        begin
          coeffTableOut0_1 = 18'sb000000000000000000;
        end
      default :
        begin
          coeffTableOut0_1 = 18'sb000000000000000000;
        end
    endcase
  end



  always @(posedge clk)
    begin : coeffTableRegP0_2_process
      if (enb) begin
        coeffTableRegP0_3 <= coeffTableOut0_1;
      end
    end



  assign coeffNonZero_1 = coeffTableRegP0_3 != 18'sb000000000000000000;



  Addressable_Delay_Line_block8 u_delayLine0_1 (.clk(clk),
                                                .enb(enb),
                                                .dataIn(dinSM_im),  // sfix18_En14
                                                .wrEn(delayLineValidInP),
                                                .wrAddr(wrAddrP),  // ufix3
                                                .rdAddr(rdAddrDelayLine0),  // ufix3
                                                .dataOut(delayLineDataOut0_1)  // sfix18_En14
                                                );

  assign gainOut_1 = {{2{delayLineDataOut0_1[17]}}, {delayLineDataOut0_1, 16'b0000000000000000}};



  always @(posedge clk or posedge reset)
    begin : filterDelay_2_process
      if (reset == 1'b1) begin
        gainOutSwitch_1 <= 36'sh000000000;
      end
      else begin
        if (enb && coeffNonZero_1) begin
          gainOutSwitch_1 <= gainOut_1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : validOutLookahead_2_process
      if (reset == 1'b1) begin
        validOutLookahead_reg_1[0] <= 1'b0;
        validOutLookahead_reg_1[1] <= 1'b0;
        validOutLookahead_reg_1[2] <= 1'b0;
        validOutLookahead_reg_1[3] <= 1'b0;
        validOutLookahead_reg_1[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          validOutLookahead_reg_1[0] <= validOutLookahead_reg_next_1[0];
          validOutLookahead_reg_1[1] <= validOutLookahead_reg_next_1[1];
          validOutLookahead_reg_1[2] <= validOutLookahead_reg_next_1[2];
          validOutLookahead_reg_1[3] <= validOutLookahead_reg_next_1[3];
          validOutLookahead_reg_1[4] <= validOutLookahead_reg_next_1[4];
        end
      end
    end

  assign validOutLookahead_3 = validOutLookahead_reg_1[4];
  assign validOutLookahead_reg_next_1[0] = delayLineShiftEnP;
  assign validOutLookahead_reg_next_1[1] = validOutLookahead_reg_1[0];
  assign validOutLookahead_reg_next_1[2] = validOutLookahead_reg_1[1];
  assign validOutLookahead_reg_next_1[3] = validOutLookahead_reg_1[2];
  assign validOutLookahead_reg_next_1[4] = validOutLookahead_reg_1[3];



  always @(posedge clk or posedge reset)
    begin : filterDelay_3_process
      if (reset == 1'b1) begin
        filterDelay_reg_1[0] <= 36'sh000000000;
        filterDelay_reg_1[1] <= 36'sh000000000;
        filterDelay_reg_1[2] <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          filterDelay_reg_1[0] <= filterDelay_reg_next_1[0];
          filterDelay_reg_1[1] <= filterDelay_reg_next_1[1];
          filterDelay_reg_1[2] <= filterDelay_reg_next_1[2];
        end
      end
    end

  assign gainOutREG_1 = filterDelay_reg_1[2];
  assign filterDelay_reg_next_1[0] = gainOutSwitch_1;
  assign filterDelay_reg_next_1[1] = filterDelay_reg_1[0];
  assign filterDelay_reg_next_1[2] = filterDelay_reg_1[1];



  assign sumOut_1 = gainOutREG_1[33:0];



  assign converterOut_1 = sumOut_1[33:16];



  always @(posedge clk or posedge reset)
    begin : dout_im_process
      if (reset == 1'b1) begin
        dout_im_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb && validOutLookahead_3) begin
          dout_im_1 <= converterOut_1;
        end
      end
    end



  assign dataZero = 18'sb000000000000000000;



  assign dataZero_dtc_re = dataZero;
  assign dataZero_dtc_im = 18'sb000000000000000000;



  assign dout_cmplxSW_re = (notValid == 1'b0 ? dout_re_1 :
              dataZero_dtc_re);
  assign dout_cmplxSW_im = (notValid == 1'b0 ? dout_im_1 :
              dataZero_dtc_im);



  assign dataOut_re = dout_cmplxSW_re;

  assign dataOut_im = dout_cmplxSW_im;

  assign validOut = vldOut_1;

endmodule  // FIRFilter2_block

